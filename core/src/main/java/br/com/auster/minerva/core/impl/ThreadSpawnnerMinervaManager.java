/*
 /*
 * Copyright (c) 2004 Auster Solutions. All Rights Reserved.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Created on Sep 15, 2005
 */
package br.com.auster.minerva.core.impl;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.w3c.dom.Element;

import br.com.auster.common.util.I18n;
import br.com.auster.common.xml.DOMUtils;
import br.com.auster.minerva.core.MinervaConfigurationConstants;
import br.com.auster.minerva.core.Report;
import br.com.auster.minerva.core.ReportInitializationException;
import br.com.auster.minerva.spi.ReportRequest;

/**
 * Implementation of the <code>MinervaManager</code> interface, where :
 * <ul>
 * <li>dispatchers are supported</li>
 * <li>reports are executed in a specific thread</li>
 * </ul>
 * <p>
 * The threads responsible for generating reports are configured in this
 * manager, and are treated as a pool. So, if there are more requests then
 * configured threads, the last received requests will wait until a running
 * reports finishes.
 * <p>
 * The configuration layout for this implementation is :
 * 
 * <pre>
 * 
 * &lt;!-- No configuration parameters are accepted by this implementation --&gt;
 * &lt;configuration pool-size=&quot;...&quot;/&gt;
 * 
 * &lt;!-- factory class implementation --&gt;
 * &lt;factory class=&quot;...&quot;&gt;
 *     &lt;!-- factory configuration area --&gt;
 *     &lt;configuration&gt;
 *     ...
 *     &lt;/configuration&gt;
 * &lt;/factory&gt;
 * </pre>
 * 
 * @author framos
 * @version $Id$
 */
public class ThreadSpawnnerMinervaManager extends MinervaManagerBase {

	// ----------------------------
	// Class constants
	// ----------------------------

	private static final I18n		i18n																			= I18n
																																						.getInstance(ReportFactoryBase.class);
	private static final Log		log																				= LogFactory
																																						.getLog(ReportFactoryBase.class);

	public static final String	MINERVA_MANAGER_THREADPOOL_SIZE_ATTRIBUTE	= "pool-size";

	// ----------------------------
	// Instance variables
	// ----------------------------

	protected ExecutorService		threadPool;

	// ----------------------------
	// Interface methods
	// ----------------------------

	/**
	 * @see br.com.auster.minerva.core.impl.MinervaManagerBase#enqueueRequest(br.com.auster.minerva.spi.ReportRequest)
	 */
	public boolean enqueueRequest(ReportRequest _request) {
		if (factory == null) {
			throw new IllegalStateException(i18n
					.getString("manager.threaded.noFactoryFound"));
		}
		Report report = factory.getReport(_request);
    log.trace("Report generated by factory(" + factory.getClass().getName() + ")" + 
    		".ReportClass:" + report.getClass().getCanonicalName() + ".R.toString()" + report);	
    
		log.debug(i18n.getString("manager.threaded.reportExecuted", _request
				.getName()));
		Future<?> name = threadPool.submit(new ReportThread(report, _request));
		log.trace("Future returned from submission at thread pool:" + name.getClass().getName() + ".->" + name);
		return true;
	}

	/**
	 * @see br.com.auster.minerva.core.impl.MinervaManagerBase#configure(Element)
	 */
	public void configure(Element _configuration)
			throws ReportInitializationException {
		super.configure(_configuration);
		// configuring thread pool size
		Element c = DOMUtils.getElement(_configuration,
				MinervaConfigurationConstants.MINERVA_CONFIGURATION_SUBELEMENT, true);
		int poolSize = DOMUtils.getIntAttribute(c,
				MINERVA_MANAGER_THREADPOOL_SIZE_ATTRIBUTE, false);
		if (poolSize <= 0) {
			poolSize = 1;
		}
		log.info(i18n.getString("manager.threaded.poolSizeSet", String
				.valueOf(poolSize)));
		this.threadPool = Executors.newFixedThreadPool(poolSize);
	}

	// ----------------------------
	// Inner classes
	// ----------------------------

	private class ReportThread implements Runnable {

		private Report				report;
		private ReportRequest	request;

		ReportThread(Report _report, ReportRequest _request) {
			report = _report;
			request = _request;
		}

		/**
		 * @see java.lang.Runnable#run()
		 */
		public void run() {
			log.trace("Running report.");
			log.trace("Report Class:" + report.getClass().getName() + ".toStrng:" + report);
			report.generate(request);
		}
	}
}
